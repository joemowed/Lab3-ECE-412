
lab 3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000060  00800100  00000354  000003e8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000354  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000c  00800160  00800160  00000448  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000448  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000478  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000a0  00000000  00000000  000004b8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000130e  00000000  00000000  00000558  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000aea  00000000  00000000  00001866  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000008ae  00000000  00000000  00002350  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000118  00000000  00000000  00002c00  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000067f  00000000  00000000  00002d18  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000002d2  00000000  00000000  00003397  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000070  00000000  00000000  00003669  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
   4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
   8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
   c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  18:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  24:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  28:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  30:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  34:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  38:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  48:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  7c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  80:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  84:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  88:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  8c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  90:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  94:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  98:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  9c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a8:	0c 94 49 01 	jmp	0x292	; 0x292 <__vector_42>
  ac:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  b0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>

000000b4 <__ctors_end>:
  b4:	11 24       	eor	r1, r1
  b6:	1f be       	out	0x3f, r1	; 63
  b8:	cf ef       	ldi	r28, 0xFF	; 255
  ba:	d8 e0       	ldi	r29, 0x08	; 8
  bc:	de bf       	out	0x3e, r29	; 62
  be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
  c0:	11 e0       	ldi	r17, 0x01	; 1
  c2:	a0 e0       	ldi	r26, 0x00	; 0
  c4:	b1 e0       	ldi	r27, 0x01	; 1
  c6:	e4 e5       	ldi	r30, 0x54	; 84
  c8:	f3 e0       	ldi	r31, 0x03	; 3
  ca:	02 c0       	rjmp	.+4      	; 0xd0 <UDR0+0xa>
  cc:	05 90       	lpm	r0, Z+
  ce:	0d 92       	st	X+, r0
  d0:	a0 36       	cpi	r26, 0x60	; 96
  d2:	b1 07       	cpc	r27, r17
  d4:	d9 f7       	brne	.-10     	; 0xcc <UDR0+0x6>

000000d6 <__do_clear_bss>:
  d6:	21 e0       	ldi	r18, 0x01	; 1
  d8:	a0 e6       	ldi	r26, 0x60	; 96
  da:	b1 e0       	ldi	r27, 0x01	; 1
  dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
  de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
  e0:	ac 36       	cpi	r26, 0x6C	; 108
  e2:	b2 07       	cpc	r27, r18
  e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
  e6:	0e 94 8c 01 	call	0x318	; 0x318 <main>
  ea:	0c 94 a8 01 	jmp	0x350	; 0x350 <_exit>

000000ee <__bad_interrupt>:
  ee:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000f2 <Mega328P_Init>:
.set	temp,0				;student comment here

.section ".text"			;student comment here
.global Mega328P_Init
Mega328P_Init:
		ldi	r16,0x07		;PB0(R*W),PB1(RS),PB2(E) as fixed outputs
  f2:	07 e0       	ldi	r16, 0x07	; 7
		out	DDRB,r16		;student comment here
  f4:	04 b9       	out	0x04, r16	; 4
		ldi	r16,0			;student comment here
  f6:	00 e0       	ldi	r16, 0x00	; 0
		out	PORTB,r16		;student comment here
  f8:	05 b9       	out	0x05, r16	; 5
		out	U2X0,r16		;initialize UART, 8bits, no parity, 1 stop, 9600
  fa:	01 b9       	out	0x01, r16	; 1
		ldi	r17,0x0			;student comment here
  fc:	10 e0       	ldi	r17, 0x00	; 0
		ldi	r16,0x67		;student comment here
  fe:	07 e6       	ldi	r16, 0x67	; 103
		sts	UBRR0H,r17		;student comment here
 100:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
		sts	UBRR0L,r16		;student comment here
 104:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
		ldi	r16,24			;student comment here
 108:	08 e1       	ldi	r16, 0x18	; 24
		sts	UCSR0B,r16		;student comment here
 10a:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
		ldi	r16,6			;student comment here
 10e:	06 e0       	ldi	r16, 0x06	; 6
		sts	UCSR0C,r16		;student comment here
 110:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
		ldi r16,0x87		;initialize ADC
 114:	07 e8       	ldi	r16, 0x87	; 135
		sts	ADCSRA,r16		;student comment here
 116:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7f807a>
		ldi r16,0x40		;student comment here
 11a:	00 e4       	ldi	r16, 0x40	; 64
		sts ADMUX,r16		;student comment here
 11c:	00 93 7c 00 	sts	0x007C, r16	; 0x80007c <__TEXT_REGION_LENGTH__+0x7f807c>
		ldi r16,0			;student comment here
 120:	00 e0       	ldi	r16, 0x00	; 0
		sts ADCSRB,r16		;student comment here
 122:	00 93 7b 00 	sts	0x007B, r16	; 0x80007b <__TEXT_REGION_LENGTH__+0x7f807b>
		ldi r16,0xFE		;student comment here
 126:	0e ef       	ldi	r16, 0xFE	; 254
		sts DIDR0,r16		;student comment here
 128:	00 93 7e 00 	sts	0x007E, r16	; 0x80007e <__TEXT_REGION_LENGTH__+0x7f807e>
		ldi r16,0xFF		;student comment here
 12c:	0f ef       	ldi	r16, 0xFF	; 255
		sts DIDR1,r16		;student comment here
 12e:	00 93 7f 00 	sts	0x007F, r16	; 0x80007f <__TEXT_REGION_LENGTH__+0x7f807f>
		ret					;student comment here
 132:	08 95       	ret

00000134 <LCD_Write_Command>:
	
.global LCD_Write_Command
LCD_Write_Command:
	call	UART_Off		;student comment here
 134:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
	ldi		r16,0xFF		;PD0 - PD7 as outputs
 138:	0f ef       	ldi	r16, 0xFF	; 255
	out		DDRD,r16		;student comment here
 13a:	0a b9       	out	0x0a, r16	; 10
	lds		r16,DATA		;student comment here
 13c:	00 91 61 01 	lds	r16, 0x0161	; 0x800161 <DATA>
	out		PORTD,r16		;student comment here
 140:	0b b9       	out	0x0b, r16	; 11
	ldi		r16,4			;student comment here
 142:	04 e0       	ldi	r16, 0x04	; 4
	out		PORTB,r16		;student comment here
 144:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		;student comment here
 146:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
	ldi		r16,0			;student comment here
 14a:	00 e0       	ldi	r16, 0x00	; 0
	out		PORTB,r16		;student comment here
 14c:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		;student comment here
 14e:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
	call	UART_On			;student comment here
 152:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
	ret						;student comment here
 156:	08 95       	ret

00000158 <LCD_Delay>:

LCD_Delay:
	ldi		r16,0xFf		;student comment here
 158:	0f ef       	ldi	r16, 0xFF	; 255

0000015a <D0>:
D0:	ldi		r17,0xFF		;student comment here
 15a:	1f ef       	ldi	r17, 0xFF	; 255

0000015c <D1>:
D1:	dec		r17				;student comment here
 15c:	1a 95       	dec	r17
	brne	D1				;student comment here
 15e:	f1 f7       	brne	.-4      	; 0x15c <D1>
	dec		r16				;student comment here
 160:	0a 95       	dec	r16
	brne	D0				;student comment here
 162:	d9 f7       	brne	.-10     	; 0x15a <D0>
	ret						;student comment here
 164:	08 95       	ret

00000166 <LCD_Write_Data>:

.global LCD_Write_Data
LCD_Write_Data:
	call	UART_Off		;student comment here
 166:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
	ldi		r16,0xFF		;student comment here
 16a:	0f ef       	ldi	r16, 0xFF	; 255
	out		DDRD,r16		;student comment here
 16c:	0a b9       	out	0x0a, r16	; 10
	lds		r16,DATA		;student comment here
 16e:	00 91 61 01 	lds	r16, 0x0161	; 0x800161 <DATA>
	out		PORTD,r16		;student comment here
 172:	0b b9       	out	0x0b, r16	; 11
	ldi		r16,6			;student comment here
 174:	06 e0       	ldi	r16, 0x06	; 6
	out		PORTB,r16		;student comment here
 176:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		;student comment here
 178:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
	ldi		r16,0			;student comment here
 17c:	00 e0       	ldi	r16, 0x00	; 0
	out		PORTB,r16		;student comment here
 17e:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		;student comment here
 180:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
	call	UART_On			;student comment here
 184:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
	ret						;student comment here
 188:	08 95       	ret

0000018a <LCD_Read_Data>:

.global LCD_Read_Data
LCD_Read_Data:
	call	UART_Off		;student comment here
 18a:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
	ldi		r16,0x00		;student comment here
 18e:	00 e0       	ldi	r16, 0x00	; 0
	out		DDRD,r16		;student comment here
 190:	0a b9       	out	0x0a, r16	; 10
	out		PORTB,4			;student comment here
 192:	45 b8       	out	0x05, r4	; 5
	in		r16,PORTD		;student comment here
 194:	0b b1       	in	r16, 0x0b	; 11
	sts		DATA,r16		;student comment here
 196:	00 93 61 01 	sts	0x0161, r16	; 0x800161 <DATA>
	out		PORTB,0			;student comment here
 19a:	05 b8       	out	0x05, r0	; 5
	call	UART_On			;student comment here
 19c:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
	ret						;student comment here
 1a0:	08 95       	ret

000001a2 <UART_On>:

.global UART_On
UART_On:
	ldi		r16,2				;student comment here
 1a2:	02 e0       	ldi	r16, 0x02	; 2
	out		DDRD,r16			;student comment here
 1a4:	0a b9       	out	0x0a, r16	; 10
	ldi		r16,24				;student comment here
 1a6:	08 e1       	ldi	r16, 0x18	; 24
	sts		UCSR0B,r16			;student comment here
 1a8:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
	ret							;student comment here
 1ac:	08 95       	ret

000001ae <UART_Off>:

.global UART_Off
UART_Off:
	ldi	r16,0					;student comment here
 1ae:	00 e0       	ldi	r16, 0x00	; 0
	sts UCSR0B,r16				;student comment here
 1b0:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
	ret							;student comment here
 1b4:	08 95       	ret

000001b6 <UART_Clear>:

.global UART_Clear
UART_Clear:
	lds		r16,UCSR0A			;student comment here
 1b6:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
	sbrs	r16,RXC0			;student comment here
 1ba:	07 ff       	sbrs	r16, 7
	ret							;student comment here
 1bc:	08 95       	ret
	lds		r16,UDR0			;student comment here
 1be:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
	rjmp	UART_Clear			;student comment here
 1c2:	f9 cf       	rjmp	.-14     	; 0x1b6 <UART_Clear>

000001c4 <UART_Get>:

.global UART_Get
UART_Get:
	lds		r16,UCSR0A			;student comment here
 1c4:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
	sbrs	r16,RXC0			;student comment here
 1c8:	07 ff       	sbrs	r16, 7
	rjmp	UART_Get			;student comment here
 1ca:	fc cf       	rjmp	.-8      	; 0x1c4 <UART_Get>
	lds		r16,UDR0			;student comment here
 1cc:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
	sts		ASCII,r16			;student comment here
 1d0:	00 93 63 01 	sts	0x0163, r16	; 0x800163 <ASCII>
	ret							;student comment here
 1d4:	08 95       	ret

000001d6 <UART_Put>:

.global UART_Put
UART_Put:
	lds		r17,UCSR0A			;student comment here
 1d6:	10 91 c0 00 	lds	r17, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
	sbrs	r17,UDRE0			;student comment here
 1da:	15 ff       	sbrs	r17, 5
	rjmp	UART_Put			;student comment here
 1dc:	fc cf       	rjmp	.-8      	; 0x1d6 <UART_Put>
	lds		r16,ASCII			;student comment here
 1de:	00 91 63 01 	lds	r16, 0x0163	; 0x800163 <ASCII>
	sts		UDR0,r16			;student comment here
 1e2:	00 93 c6 00 	sts	0x00C6, r16	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
	ret							;student comment here
 1e6:	08 95       	ret

000001e8 <ADC_Get>:

.global ADC_Get
ADC_Get:
		ldi		r16,0xC7			;student comment here
 1e8:	07 ec       	ldi	r16, 0xC7	; 199
		sts		ADCSRA,r16			;student comment here
 1ea:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7f807a>

000001ee <A2V1>:
A2V1:	lds		r16,ADCSRA			;student comment here
 1ee:	00 91 7a 00 	lds	r16, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7f807a>
		sbrc	r16,ADSC			;student comment here
 1f2:	06 fd       	sbrc	r16, 6
		rjmp 	A2V1				;student comment here
 1f4:	fc cf       	rjmp	.-8      	; 0x1ee <A2V1>
		lds		r16,ADCL			;student comment here
 1f6:	00 91 78 00 	lds	r16, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7f8078>
		sts		LADC,r16			;student comment here
 1fa:	00 93 69 01 	sts	0x0169, r16	; 0x800169 <LADC>
		lds		r16,ADCH			;student comment here
 1fe:	00 91 79 00 	lds	r16, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7f8079>
		sts		HADC,r16			;student comment here
 202:	00 93 62 01 	sts	0x0162, r16	; 0x800162 <HADC>
		ret							;student comment here
 206:	08 95       	ret

00000208 <EEPROM_Write>:

.global EEPROM_Write
EEPROM_Write:      
		sbic    EECR,EEPE
 208:	f9 99       	sbic	0x1f, 1	; 31
		rjmp    EEPROM_Write		; Wait for completion of previous write
 20a:	fe cf       	rjmp	.-4      	; 0x208 <EEPROM_Write>
		ldi		r18,0x00			; Set up address (r18:r17) in address register
 20c:	20 e0       	ldi	r18, 0x00	; 0
		ldi		r17,0x05 
 20e:	15 e0       	ldi	r17, 0x05	; 5
		ldi		r16,'F'				; Set up data in r16    
 210:	06 e4       	ldi	r16, 0x46	; 70
		out     EEARH, r18      
 212:	22 bd       	out	0x22, r18	; 34
		out     EEARL, r17			      
 214:	11 bd       	out	0x21, r17	; 33
		out     EEDR,r16			; Write data (r16) to Data Register  
 216:	00 bd       	out	0x20, r16	; 32
		sbi     EECR,EEMPE			; Write logical one to EEMPE
 218:	fa 9a       	sbi	0x1f, 2	; 31
		sbi     EECR,EEPE			; Start eeprom write by setting EEPE
 21a:	f9 9a       	sbi	0x1f, 1	; 31
		ret 
 21c:	08 95       	ret

0000021e <EEPROM_Read>:

.global EEPROM_Read
EEPROM_Read:					    
		sbic    EECR,EEPE    
 21e:	f9 99       	sbic	0x1f, 1	; 31
		rjmp    EEPROM_Read		; Wait for completion of previous write
 220:	fe cf       	rjmp	.-4      	; 0x21e <EEPROM_Read>
		ldi		r18,0x00		; Set up address (r18:r17) in EEPROM address register
 222:	20 e0       	ldi	r18, 0x00	; 0
		ldi		r17,0x05
 224:	15 e0       	ldi	r17, 0x05	; 5
		ldi		r16,0x00   
 226:	00 e0       	ldi	r16, 0x00	; 0
		out     EEARH, r18   
 228:	22 bd       	out	0x22, r18	; 34
		out     EEARL, r17		   
 22a:	11 bd       	out	0x21, r17	; 33
		sbi     EECR,EERE		; Start eeprom read by writing EERE
 22c:	f8 9a       	sbi	0x1f, 0	; 31
		in      r16,EEDR		; Read data from Data Register
 22e:	00 b5       	in	r16, 0x20	; 32
		sts		ASCII,r16  
 230:	00 93 63 01 	sts	0x0163, r16	; 0x800163 <ASCII>
		ret
 234:	08 95       	ret

00000236 <UART_Puts>:
	return (Port)(portRegister-2);
}
void portConfigInput( volatile uint8_t* portaddress,uint8_t pin){
	Port port = getAddrFromPort(portaddress);
	CLEAR_BIT(port->PORTx,pin);
	CLEAR_BIT(port->DDRx,pin);
 236:	cf 93       	push	r28
 238:	df 93       	push	r29
 23a:	ec 01       	movw	r28, r24
 23c:	05 c0       	rjmp	.+10     	; 0x248 <UART_Puts+0x12>
 23e:	21 96       	adiw	r28, 0x01	; 1
 240:	80 93 63 01 	sts	0x0163, r24	; 0x800163 <ASCII>
 244:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <UART_Put>
 248:	88 81       	ld	r24, Y
 24a:	81 11       	cpse	r24, r1
 24c:	f8 cf       	rjmp	.-16     	; 0x23e <UART_Puts+0x8>
 24e:	df 91       	pop	r29
 250:	cf 91       	pop	r28
 252:	08 95       	ret

00000254 <Banner>:
 254:	81 e4       	ldi	r24, 0x41	; 65
 256:	91 e0       	ldi	r25, 0x01	; 1
 258:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
 25c:	8a e0       	ldi	r24, 0x0A	; 10
 25e:	91 e0       	ldi	r25, 0x01	; 1
 260:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
 264:	80 e0       	ldi	r24, 0x00	; 0
 266:	91 e0       	ldi	r25, 0x01	; 1
 268:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
 26c:	08 95       	ret

0000026e <portConfigOutput>:
	return;
}

void portConfigOutput( volatile uint8_t* portaddress,uint8_t pin){
	Port port = getAddrFromPort(portaddress);
	CLEAR_BIT(port->PORTx,pin);
 26e:	fc 01       	movw	r30, r24
 270:	32 97       	sbiw	r30, 0x02	; 2
 272:	82 81       	ldd	r24, Z+2	; 0x02
 274:	21 e0       	ldi	r18, 0x01	; 1
 276:	30 e0       	ldi	r19, 0x00	; 0
 278:	02 c0       	rjmp	.+4      	; 0x27e <portConfigOutput+0x10>
 27a:	22 0f       	add	r18, r18
 27c:	33 1f       	adc	r19, r19
 27e:	6a 95       	dec	r22
 280:	e2 f7       	brpl	.-8      	; 0x27a <portConfigOutput+0xc>
 282:	92 2f       	mov	r25, r18
 284:	90 95       	com	r25
 286:	89 23       	and	r24, r25
 288:	82 83       	std	Z+2, r24	; 0x02
	SET_BIT(port->DDRx,pin);
 28a:	81 81       	ldd	r24, Z+1	; 0x01
 28c:	28 2b       	or	r18, r24
 28e:	21 83       	std	Z+1, r18	; 0x01
 290:	08 95       	ret

00000292 <__vector_42>:
#define DELAY_ISR_HANDLE TIMER4_COMPA_vect
#else
#error selected timer not a valid timer for delaymicroseconds
#endif
volatile bool waitFlagForDelay = false;
ISR(DELAY_ISR_HANDLE,ISR_BLOCK){
 292:	1f 92       	push	r1
 294:	0f 92       	push	r0
 296:	0f b6       	in	r0, 0x3f	; 63
 298:	0f 92       	push	r0
 29a:	11 24       	eor	r1, r1
 29c:	8f 93       	push	r24
	waitFlagForDelay = true;
 29e:	81 e0       	ldi	r24, 0x01	; 1
 2a0:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <__data_end>
	DELAY_CTRLB = 0x0;
 2a4:	10 92 a1 00 	sts	0x00A1, r1	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7f80a1>
}
 2a8:	8f 91       	pop	r24
 2aa:	0f 90       	pop	r0
 2ac:	0f be       	out	0x3f, r0	; 63
 2ae:	0f 90       	pop	r0
 2b0:	1f 90       	pop	r1
 2b2:	18 95       	reti

000002b4 <delayMicroseconds>:
}
inline void startTimer(volatile uint8_t*CTRLB){
	*CTRLB = ((0x1<<WGM12)|(0x1)); // 0x1 sets clk src to cpu clk and starts timer.  CTC mode auto-resets the count on compareA match
}
inline void stopTimer(volatile uint8_t*CTRLB){
	*CTRLB = 0x0;
 2b4:	10 92 a1 00 	sts	0x00A1, r1	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7f80a1>
	writeTimerRegisterWord(OCRAL,compare);
	*timerISRMSK = (1<<OCIE1A);//enable only the a compare interrupt
}
inline uint16_t microsecondsToPeriodCount(uint16_t value){
	const uint16_t minMicroseconds = 8; //The time it takes for delayMicroseconds to operate,if the interrupt triggers instantly
	if(value < minMicroseconds){
 2b8:	88 30       	cpi	r24, 0x08	; 8
 2ba:	91 05       	cpc	r25, r1
 2bc:	68 f0       	brcs	.+26     	; 0x2d8 <delayMicroseconds+0x24>
		return 1;
	}
	if(value > 4090){ //~4090 is max for 16bit timer at 16mhz
 2be:	8b 3f       	cpi	r24, 0xFB	; 251
 2c0:	2f e0       	ldi	r18, 0x0F	; 15
 2c2:	92 07       	cpc	r25, r18
 2c4:	60 f4       	brcc	.+24     	; 0x2de <delayMicroseconds+0x2a>
		return UINT16_MAX;
	}
	return ((value<<4) - ((minMicroseconds-3)<<4)); //works because 16mhz has 1/16 microsecond period
 2c6:	82 95       	swap	r24
 2c8:	92 95       	swap	r25
 2ca:	90 7f       	andi	r25, 0xF0	; 240
 2cc:	98 27       	eor	r25, r24
 2ce:	80 7f       	andi	r24, 0xF0	; 240
 2d0:	98 27       	eor	r25, r24
 2d2:	80 55       	subi	r24, 0x50	; 80
 2d4:	91 09       	sbc	r25, r1
 2d6:	05 c0       	rjmp	.+10     	; 0x2e2 <delayMicroseconds+0x2e>
	*timerISRMSK = (1<<OCIE1A);//enable only the a compare interrupt
}
inline uint16_t microsecondsToPeriodCount(uint16_t value){
	const uint16_t minMicroseconds = 8; //The time it takes for delayMicroseconds to operate,if the interrupt triggers instantly
	if(value < minMicroseconds){
		return 1;
 2d8:	81 e0       	ldi	r24, 0x01	; 1
 2da:	90 e0       	ldi	r25, 0x00	; 0
 2dc:	02 c0       	rjmp	.+4      	; 0x2e2 <delayMicroseconds+0x2e>
	}
	if(value > 4090){ //~4090 is max for 16bit timer at 16mhz
		return UINT16_MAX;
 2de:	8f ef       	ldi	r24, 0xFF	; 255
 2e0:	9f ef       	ldi	r25, 0xFF	; 255
	*highByte = (uint8_t)(value >>8);
	*lowByte = (uint8_t)(value & 0xFF);
	SREG = sreg;
}
inline void setupTimerForDelay(volatile uint8_t* CTRLB,volatile uint8_t*timerISRMSK,uint16_t compare){
	*CTRLB = 0x0; //disable the timer if it isn't already
 2e2:	e1 ea       	ldi	r30, 0xA1	; 161
 2e4:	f0 e0       	ldi	r31, 0x00	; 0
 2e6:	10 82       	st	Z, r1
	volatile uint8_t* CTRLA = (CTRLB-1);
	*CTRLA = 0x0; //reset state
 2e8:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7f80a0>
	waitFlagForDelay = true;
	DELAY_CTRLB = 0x0;
}
//required by datasheet to write high byte first
inline void writeTimerRegisterWord(volatile uint8_t*lowByte, uint16_t value){
	uint8_t sreg =SREG;
 2ec:	2f b7       	in	r18, 0x3f	; 63
	cli();
 2ee:	f8 94       	cli
	volatile uint8_t*const highByte = (lowByte +1);
	*highByte = (uint8_t)(value >>8);
 2f0:	90 87       	std	Z+8, r25	; 0x08
	*lowByte = (uint8_t)(value & 0xFF);
 2f2:	87 83       	std	Z+7, r24	; 0x07
	SREG = sreg;
 2f4:	2f bf       	out	0x3f, r18	; 63
	*CTRLB = 0x0; //disable the timer if it isn't already
	volatile uint8_t* CTRLA = (CTRLB-1);
	*CTRLA = 0x0; //reset state
	volatile uint8_t* OCRAL = (CTRLA+8);
	writeTimerRegisterWord(OCRAL,compare);
	*timerISRMSK = (1<<OCIE1A);//enable only the a compare interrupt
 2f6:	82 e0       	ldi	r24, 0x02	; 2
 2f8:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x7f8072>
}
//max 4090 microseconds, min 8 microseconds.  Operates with TIM1 in interrupt mode
void delayMicroseconds(uint16_t microseconds){
	stopTimer(&DELAY_CTRLB);
	setupTimerForDelay(&DELAY_CTRLB,&DELAY_ISRMSK,microsecondsToPeriodCount(microseconds));
	uint8_t sreg = SREG;
 2fc:	9f b7       	in	r25, 0x3f	; 63
	sei();
 2fe:	78 94       	sei
		return UINT16_MAX;
	}
	return ((value<<4) - ((minMicroseconds-3)<<4)); //works because 16mhz has 1/16 microsecond period
}
inline void startTimer(volatile uint8_t*CTRLB){
	*CTRLB = ((0x1<<WGM12)|(0x1)); // 0x1 sets clk src to cpu clk and starts timer.  CTC mode auto-resets the count on compareA match
 300:	89 e0       	ldi	r24, 0x09	; 9
 302:	80 83       	st	Z, r24
	stopTimer(&DELAY_CTRLB);
	setupTimerForDelay(&DELAY_CTRLB,&DELAY_ISRMSK,microsecondsToPeriodCount(microseconds));
	uint8_t sreg = SREG;
	sei();
	startTimer(&DELAY_CTRLB);
	while(!waitFlagForDelay){}
 304:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <__data_end>
 308:	88 23       	and	r24, r24
 30a:	e1 f3       	breq	.-8      	; 0x304 <delayMicroseconds+0x50>
	waitFlagForDelay = false;
 30c:	10 92 60 01 	sts	0x0160, r1	; 0x800160 <__data_end>
	SREG = sreg;
 310:	9f bf       	out	0x3f, r25	; 63
}
inline void startTimer(volatile uint8_t*CTRLB){
	*CTRLB = ((0x1<<WGM12)|(0x1)); // 0x1 sets clk src to cpu clk and starts timer.  CTC mode auto-resets the count on compareA match
}
inline void stopTimer(volatile uint8_t*CTRLB){
	*CTRLB = 0x0;
 312:	10 92 a1 00 	sts	0x00A1, r1	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7f80a1>
 316:	08 95       	ret

00000318 <main>:
}
#include "portapi.h"
#include "delay.h"
int main(void)
{
	Mega328P_Init();
 318:	0e 94 79 00 	call	0xf2	; 0xf2 <Mega328P_Init>
	Banner();
 31c:	0e 94 2a 01 	call	0x254	; 0x254 <Banner>
	portConfigOutput(&PORTC,5);
 320:	65 e0       	ldi	r22, 0x05	; 5
 322:	88 e2       	ldi	r24, 0x28	; 40
 324:	90 e0       	ldi	r25, 0x00	; 0
 326:	0e 94 37 01 	call	0x26e	; 0x26e <portConfigOutput>
	return;
}
//takes  438ns with inline (7 cycles)
inline void portWritePin( volatile uint8_t* portaddress,uint8_t pin,bool value){
	Port port = getAddrFromPort(portaddress);
	SET_BIT_VALUE(port->PORTx,pin,value);
 32a:	88 b1       	in	r24, 0x08	; 8
 32c:	90 e0       	ldi	r25, 0x00	; 0
 32e:	80 95       	com	r24
 330:	90 95       	com	r25
 332:	80 72       	andi	r24, 0x20	; 32
 334:	99 27       	eor	r25, r25
 336:	98 b1       	in	r25, 0x08	; 8
 338:	89 27       	eor	r24, r25
 33a:	88 b9       	out	0x08, r24	; 8
	while(true){
	portWritePin(&PORTC,5,1);
	delayMicroseconds(50);
 33c:	82 e3       	ldi	r24, 0x32	; 50
 33e:	90 e0       	ldi	r25, 0x00	; 0
 340:	0e 94 5a 01 	call	0x2b4	; 0x2b4 <delayMicroseconds>
 344:	88 b1       	in	r24, 0x08	; 8
 346:	98 b1       	in	r25, 0x08	; 8
 348:	80 72       	andi	r24, 0x20	; 32
 34a:	89 27       	eor	r24, r25
 34c:	88 b9       	out	0x08, r24	; 8
 34e:	ed cf       	rjmp	.-38     	; 0x32a <main+0x12>

00000350 <_exit>:
 350:	f8 94       	cli

00000352 <__stop_program>:
 352:	ff cf       	rjmp	.-2      	; 0x352 <__stop_program>
